# [1.Two Sum](https://leetcode.com/problems/two-sum/)
## 题目
Given an array of integers `nums` and an integer `target`, return *indices of the two numbers such that they add up to `target`*.

You may assume that each input would have **exactly one solution**, and you may not use the *same* element twice.

You can return the answer in any order.
## 题目大意
给定一个整数数组`nums`和整数`target`，要求在`nums`中找到两个**不同下标**的数——它们相加等于`target`——返回这两个数的下标**（任意顺序）**。
## 样例
### 数据范围
- ![](https://latex.codecogs.com/svg.latex?2%20\leqslant%20\text{nums.length}%20\leqslant%2010^3)
- ![](https://latex.codecogs.com/svg.latex?-10^9%20\leqslant%20\text{nums[i]}%20\leqslant%2010^9)
- ![](https://latex.codecogs.com/svg.latex?-10^9%20\leqslant%20\text{target}%20\leqslant%2010^9)
### 样例一
```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
```
### 样例二
```
Input: nums = [3,2,4], target = 6  
Output: [1,2]
```
### 样例三
```
Input: nums = [3,3], target = 6  
Output: [0,1]
```
## 题解
从头遍历`nums`数组，检查`target - num`是否在字典`numsDict`中：
- 若在，则说明当前元素的值与其**之前的某个元素**的值相加等于`target`，这组数显然符合题意，于是我们直接返回由这两个数的下标组成的列表`[numsDict.get(target - num), index]`
- 若不在，我们以当前元素的值为`key`，当前元素的下标为`value`存入`numsDict`中

如此，只需遍历一遍`nums`数组就一定能找到答案，因而时间复杂度为![](https://latex.codecogs.com/svg.latex?O(n))。下面附上AC代码：
```py
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        numsDict = {}
        for index, num in enumerate(nums):
            if numsDict.get(target - num) is not None:
                return [numsDict.get(target - num), index]
            else:
                numsDict[num] = index
```